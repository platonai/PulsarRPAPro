name: Common Workflow Steps
description: A reusable composite action for common CI/CD steps with enhanced error handling and monitoring
inputs:
  image_name:
    description: Docker image name
    required: true
  version:
    description: Application version
    required: true
  deepseek_api_key:
    description: DeepSeek API key
    required: true
  proxy_rotation_url:
    description: Proxy rotation URL
    required: true
  java_version:
    description: Java version to use
    required: false
    default: '17'
  maven_profiles:
    description: Maven profiles to activate
    required: false
    default: 'all-modules'
  test_timeout:
    description: Test timeout in minutes
    required: false
    default: '35'
  service_port:
    description: Service port
    required: false
    default: '8182'
  health_check_timeout:
    description: Health check timeout in minutes
    required: false
    default: '2'

runs:
  using: "composite"
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: ${{ inputs.java_version }}
        cache: maven

    - name: Install jq for JSON parsing
      shell: bash
      run: |
        if ! command -v jq &> /dev/null; then
          sudo apt-get update -qq
          sudo apt-get install -y jq
        fi

    - name: Read VERSION
      id: version
      shell: bash
      run: |
        if [ -f VERSION ]; then
          VERSION=$(head -n 1 VERSION | tr -d '\n\r')
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Found VERSION file: $VERSION"
        else
          echo "VERSION file not found, using input version: ${{ inputs.version }}"
          echo "VERSION=${{ inputs.version }}" >> $GITHUB_ENV
        fi

    - name: Cache Maven packages
      uses: actions/cache@v4
      with:
        path: ~/.m2/repository
        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
        restore-keys: |
          ${{ runner.os }}-maven-

    - name: Setup Permissions
      shell: bash
      run: |
        echo "::group::Setting up permissions"
        
        # Set execute permissions for shell scripts
        if [ -d "bin/" ]; then
          find bin/ -name "*.sh" -exec chmod +x {} \;
          echo "âœ… Set execute permissions for bin/ scripts"
        fi
        
        # Set execute permissions for Maven wrapper
        if [ -f "./mvnw" ]; then
          chmod +x ./mvnw
          echo "âœ… Set execute permissions for Maven wrapper"
        fi
        
        echo "::endgroup::"

    - name: Start Dependencies
      shell: bash
      run: |
        echo "::group::Starting Dependencies"
        
        # Start Docker Compose services
        docker compose up -d
        
        # Wait a moment for services to initialize
        sleep 5
        
        echo "::endgroup::"

    - name: Verify Dependencies
      shell: bash
      run: |
        echo "::group::Verifying Dependencies"
        
        # Show running containers
        echo "ğŸ“‹ Running containers:"
        docker ps -a
        
        echo ""
        echo "ğŸŒ Docker networks:"
        docker network ls
        
        # Check network details
        if docker network inspect scent_backend > /dev/null 2>&1; then
          echo ""
          echo "ğŸ”— Network details:"
          docker network inspect scent_backend --format '{{json .}}' | jq '{Name: .Name, Driver: .Driver, Containers: .Containers}'
        fi
        
        # Check MongoDB with timeout
        echo ""
        echo "::group::MongoDB Status"
        if docker ps --filter "name=mongodb" --filter "status=running" | grep -q mongodb; then
          echo "âœ… MongoDB container is running"
        
          # Wait for MongoDB to be ready with manual timeout
          echo "â³ Waiting for MongoDB to be ready..."
          for i in {1..60}; do
            if timeout 10 docker exec mongodb mongosh --eval "db.adminCommand('ping')" > /dev/null 2>&1; then
              echo "âœ… MongoDB is ready"
              break
            fi
            echo "â³ Waiting for MongoDB to be ready... ($i/60)"
            sleep 2
            if [ $i -eq 60 ]; then
              echo "âŒ MongoDB failed to become ready after 2 minutes"
              docker logs --tail 50 mongodb
              exit 1
            fi
          done
        else
          echo "âŒ MongoDB container is not running"
          docker logs --tail 100 mongodb || true
          exit 1
        fi
        echo "::endgroup::"
        
        # Check Redis with timeout
        echo ""
        echo "::group::Redis Status"
        if docker ps --filter "name=redis" --filter "status=running" | grep -q redis; then
          echo "âœ… Redis container is running"
        
          # Wait for Redis to be ready with manual timeout
          echo "â³ Waiting for Redis to be ready..."
          for i in {1..40}; do
            if timeout 5 docker exec redis redis-cli ping | grep -q PONG; then
              echo "âœ… Redis is ready"
              break
            fi
            echo "â³ Waiting for Redis to be ready... ($i/40)"
            sleep 1
            if [ $i -eq 40 ]; then
              echo "âŒ Redis failed to become ready after 40 seconds"
              docker logs --tail 50 redis
              exit 1
            fi
          done
        else
          echo "âŒ Redis container is not running"
          docker logs --tail 100 redis || true
          exit 1
        fi
        echo "::endgroup::"
        
        echo "::endgroup::"

    - name: Maven Build
      shell: bash
      run: |
        echo "::group::Maven Build"
        
        echo "ğŸ”¨ Building with Maven..."
        echo "Profiles: ${{ inputs.maven_profiles }}"
        echo "Java Version: ${{ inputs.java_version }}"
        
        # Set timeout using timeout command (15 minutes = 900 seconds)
        if ! timeout 900 ./mvnw clean install -DskipTests -P${{ inputs.maven_profiles }} -B -V; then
          echo "âŒ Maven build timed out or failed"
          exit 1
        fi
        
        echo "âœ… Maven build completed successfully"
        echo "::endgroup::"

    - name: Run Tests
      shell: bash
      run: |
        echo "::group::Running Tests"
        
        echo "ğŸ§ª Running tests..."
        echo "Profiles: ${{ inputs.maven_profiles }}"
        echo "Excluded: **ai/platon/scent/rest/api/integration**"
        echo "Timeout: ${{ inputs.test_timeout }} minutes"
        
        # Convert minutes to seconds for timeout command
        test_timeout_seconds=$(( ${{ fromJSON(inputs.test_timeout) }} * 60 ))
        
        if ! timeout $test_timeout_seconds ./mvnw test -P${{ inputs.maven_profiles }} -Dsurefire.excludes=**ai/platon/scent/rest/api/integration** -B; then
          echo "âŒ Tests timed out or failed"
          exit 1
        fi
        
        echo "âœ… Tests completed successfully"
        echo "::endgroup::"

    - name: Build Docker Image
      shell: bash
      run: |
        echo "::group::Building Docker Image"
        
        echo "ğŸ³ Building Docker image..."
        echo "Image: ${{ inputs.image_name }}:${{ inputs.version }}"
        echo "Latest: ${{ inputs.image_name }}:latest"
        
        # Set timeout for Docker build (10 minutes = 600 seconds)
        if ! timeout 600 docker build \
          -t ${{ inputs.image_name }}:${{ inputs.version }} \
          -t ${{ inputs.image_name }}:latest \
          -f Dockerfile .; then
          echo "âŒ Docker build timed out or failed"
          exit 1
        fi
        
        # Show image info
        echo ""
        echo "ğŸ“Š Image information:"
        docker images ${{ inputs.image_name }} --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
        
        echo "âœ… Docker image built successfully"
        echo "::endgroup::"

    - name: Start Application Container
      shell: bash
      run: |
        echo "::group::Starting Application Container"
        
        echo "ğŸš€ Starting application container..."
        
        # Remove any existing test container
        docker rm -f pulsar-rpa-vs-test 2>/dev/null || true
        
        # Start the container
        docker run -d --name pulsar-rpa-vs-test --network scent_backend \
          -p ${{ inputs.service_port }}:${{ inputs.service_port }} \
          -e DEEPSEEK_API_KEY="${{ inputs.deepseek_api_key }}" \
          -e PROXY_ROTATION_URL="${{ inputs.proxy_rotation_url }}" \
          -e gora.mongodb.servers="mongodb:27017" \
          -e SPRING_DATA_MONGODB_URI="mongodb://mongodb:27017/pulsar-rpa" \
          -e SPRING_DATA_REDIS_HOST="redis" \
          -e SPRING_DATA_REDIS_PORT="6379" \
          -e BROWSER_DISPLAY_MODE="HEADLESS" \
          -e SERVER_PORT="${{ inputs.service_port }}" \
          -e SERVER_ADDRESS="0.0.0.0" \
          ${{ inputs.image_name }}:${{ inputs.version }}
        
        echo "âœ… Container started successfully"
        echo "Container ID: $(docker ps --filter name=pulsar-rpa-vs-test --format '{{.ID}}')"
        
        # Initial wait
        echo "â³ Initial startup wait (10 seconds)..."
        sleep 10
        
        echo "::endgroup::"

    - name: Wait for Service Health
      shell: bash
      run: |
        echo "::group::Health Check"
        
        # Health check function
        check_health() {
          local temp_file=$(mktemp)
          local http_code
        
          http_code=$(curl -s -w "%{http_code}" \
            --connect-timeout 5 \
            --max-time 10 \
            "http://localhost:${{ inputs.service_port }}/actuator/health" \
            -o "$temp_file" 2>/dev/null)
        
          if [[ "$http_code" == "200" ]]; then
            if jq -e '.status == "UP"' "$temp_file" > /dev/null 2>&1; then
              echo "âœ… Service is healthy!"
              echo "Health response:"
              cat "$temp_file" | jq '.'
              rm -f "$temp_file"
              return 0
            else
              echo "âš ï¸ Service responded but status is not UP:"
              cat "$temp_file" | jq '.' || cat "$temp_file"
            fi
          else
            echo "âŒ HTTP $http_code response"
            if [[ -s "$temp_file" ]]; then
              echo "Response body:"
              cat "$temp_file"
            fi
          fi
        
          rm -f "$temp_file"
          return 1
        }
        
        # Main health check loop with manual timeout
        health_timeout_seconds=$(( ${{ fromJSON(inputs.health_check_timeout) }} * 60 ))
        max_attempts=$(( health_timeout_seconds / 3 ))  # 3 second intervals
        attempt=1
        
        echo "ğŸ” Starting health checks (max ${max_attempts} attempts, ${{ inputs.health_check_timeout }} minutes timeout)"
        echo "Health endpoint: http://localhost:${{ inputs.service_port }}/actuator/health"
        
        start_time=$(date +%s)
        
        while [ $attempt -le $max_attempts ]; do
          current_time=$(date +%s)
          elapsed_time=$((current_time - start_time))
        
          # Check if we've exceeded the timeout
          if [ $elapsed_time -ge $health_timeout_seconds ]; then
            echo "âŒ Health check timed out after $elapsed_time seconds"
            break
          fi
        
          echo ""
          echo "ğŸ” Health check attempt $attempt/$max_attempts (${elapsed_time}s elapsed)"
        
          if check_health; then
            echo "::endgroup::"
            exit 0
          fi
        
          # Show container logs every 10 attempts (30 seconds)
          if [ $((attempt % 10)) -eq 0 ]; then
            echo ""
            echo "::group::Container Status (attempt $attempt)"
            echo "Container status:"
            docker ps --filter name=pulsar-rpa-vs-test --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo ""
            echo "Recent container logs:"
            docker logs --tail 20 pulsar-rpa-vs-test 2>&1 || true
            echo "::endgroup::"
          fi
        
          sleep 3
          ((attempt++))
        done
        
        echo ""
        echo "âŒ Service failed to become healthy within ${{ inputs.health_check_timeout }} minutes"
        echo ""
        echo "::group::Final Diagnostics"
        echo "Container status:"
        docker ps -a --filter name=pulsar-rpa-vs-test
        echo ""
        echo "Full container logs:"
        docker logs pulsar-rpa-vs-test 2>&1 || true
        echo ""
        echo "Network connectivity test:"
        curl -v "http://localhost:${{ inputs.service_port }}/" 2>&1 || true
        echo "::endgroup::"
        
        echo "::endgroup::"
        exit 1

    - name: Performance Metrics
      shell: bash
      run: |
        echo "::group::Performance Metrics"
        
        echo "ğŸ“Š Container resource usage:"
        docker stats --no-stream pulsar-rpa-vs-test 2>/dev/null || true
        
        echo ""
        echo "ğŸ’¾ System memory usage:"
        free -h 2>/dev/null || true
        
        echo ""
        echo "ğŸ’¿ Disk usage:"
        df -h / 2>/dev/null || true
        
        echo ""
        echo "ğŸ³ Docker images:"
        docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedSince}}" | head -10
        
        echo "::endgroup::"

    - name: Run Integration Tests
      shell: bash
      run: |
        echo "::group::Integration Tests"
        
        echo "ğŸ§ª Running integration tests..."
        
        if [ -f "./bin/run-integration-test.sh" ]; then
          chmod +x ./bin/run-integration-test.sh
        
          # Set timeout for integration tests (10 minutes = 600 seconds)
          if ! timeout 600 ./bin/run-integration-test.sh; then
            echo "âŒ Integration tests timed out or failed"
            exit 1
          fi
        
          echo "âœ… Integration tests completed successfully"
        else
          echo "âš ï¸ Integration test script not found: ./bin/run-integration-test.sh"
          echo "Skipping integration tests..."
        fi
        
        echo "::endgroup::"

    - name: Cleanup Resources
      if: always()
      shell: bash
      run: |
        echo "::group::Cleanup Resources"
        
        # Stop and remove test container
        if docker ps -q -f name=pulsar-rpa-vs-test | grep -q .; then
          echo "ğŸ§¹ Stopping test container..."
          docker stop pulsar-rpa-vs-test || true
          docker rm pulsar-rpa-vs-test || true
          echo "âœ… Test container cleaned up"
        fi
        
        # Stop Docker Compose services
        echo "ğŸ§¹ Stopping Docker Compose services..."
        docker compose down -v || true
        echo "âœ… Docker Compose services stopped"
        
        # Clean up Docker resources (optional, commented out to avoid affecting other jobs)
        # echo "ğŸ§¹ Cleaning up unused Docker resources..."
        # docker system prune -f || true
        
        echo "âœ… Cleanup completed"
        echo "::endgroup::"

    - name: Final Status
      if: always()
      shell: bash
      run: |
        echo "::group::Final Status"
        
        if [ "${{ job.status }}" == "success" ]; then
          echo "ğŸ‰ Workflow completed successfully!"
          echo "âœ… Image: ${{ inputs.image_name }}:${{ inputs.version }}"
          echo "âœ… Service: http://localhost:${{ inputs.service_port }}"
        else
          echo "âŒ Workflow failed"
          echo "Please check the logs above for error details"
        fi
        
        echo "::endgroup::"